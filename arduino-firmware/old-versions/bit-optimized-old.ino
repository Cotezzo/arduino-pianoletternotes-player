#include <Tone.h>

// NOTES POOL TO REDUCE ARRAY SIZE USING BYTES
const int notes[] = {
  NOTE_B0, NOTE_C1, NOTE_CS1, NOTE_D1, NOTE_DS1, NOTE_E1, NOTE_F1, NOTE_FS1, NOTE_G1, NOTE_GS1, NOTE_A1, NOTE_AS1, NOTE_B1, NOTE_C2, NOTE_CS2, NOTE_D2, NOTE_DS2, NOTE_E2, NOTE_F2, NOTE_FS2, NOTE_G2, NOTE_GS2, NOTE_A2, NOTE_AS2,
  NOTE_B2, NOTE_C3, NOTE_CS3, NOTE_D3, NOTE_DS3, NOTE_E3, NOTE_F3, NOTE_FS3, NOTE_G3, NOTE_GS3, NOTE_A3, NOTE_AS3, NOTE_B3, NOTE_C4, NOTE_CS4, NOTE_D4, NOTE_DS4, NOTE_E4, NOTE_F4, NOTE_FS4, NOTE_G4, NOTE_GS4, NOTE_A4, NOTE_AS4,
  NOTE_B4, NOTE_C5, NOTE_CS5, NOTE_D5, NOTE_DS5, NOTE_E5, NOTE_F5, NOTE_FS5, NOTE_G5, NOTE_GS5, NOTE_A5, NOTE_AS5, NOTE_B5, NOTE_C6, NOTE_CS6, NOTE_D6, NOTE_DS6, NOTE_E6, NOTE_F6, NOTE_FS6, NOTE_G6, NOTE_GS6, NOTE_A6, NOTE_AS6,
  NOTE_B6, NOTE_C7, NOTE_CS7, NOTE_D7, NOTE_DS7, NOTE_E7, NOTE_F7, NOTE_FS7, NOTE_G7, NOTE_GS7, NOTE_A7, NOTE_AS7, NOTE_B7, NOTE_C8, NOTE_CS8, NOTE_D8, NOTE_DS8
};  // static note values (declared in Tone.h)

/* ---- ACTUAL MELODY ----------------------------------------------------------------------------------------------------------------------------------------------------------------- */
// SX Layer
const uint8_t hexMap_SX[] = {
0x80,0x80,0x82,0x08,0x80,0x88,0xa2,0x00,0x80,0x80,0x82,0x08,0x88,0x88,0x82,0x00,0x00,0xff,0xaa,0xba,0xaa,0xfa,0xaa,0xba,0xaa,0x90,0xab,0xaa,0xba,0xaa,0xba,0xba,0xba,0xab,0xba,0xab,0xba,0xaa,0xba,0xaa,0xaa,0xaa,0xab,0xaa,0xba,0xab,0xba,0xba,0xba,0xab,0xba,0xab,0xba,0xaa,0xba,0xba,0xaa,0xaa,0x92,0x9a,0x92,0x9a,0x92,0x9a,0x88,0x88,0x92,0x9a,0x92,0x9a,0x92,0x9a,0xaa,0xaa,0xaa,0xba,0xaa,0xfa,0xaa,0xba,0xaa,0xfa,0xaa,0xba,0xaa,0xfa,0xaa,0xba,0xaa,0xba,0xaa,0xba,0xaa,0xfa,0xaa,0xba,0xaa,0x09
};

const uint8_t PROGMEM hexNotes_SX[] = {
0x62,0xd1,0xb3,0x46,0xcd,0x9d,0xb9,0x70,0xd9,0xc3,0x87,0x6f,0x5b,0x34,0x76,0xed,0xc3,0xb7,0x6f,0x5e,0xbb,0x70,0xd9,0xc3,0x66,0x8b,0xd8,0xa0,0x68,0x81,0xb1,0xe6,0x88,0x5b,0x36,0x6c,0xed,0xcb,0x86,0xc8,0xdc,0x2c,0x46,0xe1,0x03,0xb4,0x0f,0x4f,0x36,0x4a,0xd1,0xdb,0xb7,0x0e,0xdd,0xbd,0x20,0x8d,0xa2,0xf5,0xeb,0x11,0xac,0x68,0xd0,0xf3,0x64,0xeb,0xd7,0x9e,0x4e,0xbd,0xc2,0x07,0x2a,0x1c,0x36,0x3c,0xd1,0x3b,0x67,0x06,0x5c,0xa5,0x70,0xc4,0xca,0x56,0x2c,0xda,0x21,0x68,0xa1,0x9b,0x33,0xc9,0xda,0x36,0x72,0x5d,0xc2,0x36,0xcd,0x0c,0xa5,0x70,0xe1,0x13,0x65,0x4d,0x5b,0x22,0x62,0x89,0x8a,0x04,0xec,0xd9,0xa0,0x4e,0x80,0x82,0x36,0x8b,0xd7,0xac,0x46,0xb1,0xa3,0x43,0xcd,0x93,0xaf,0x5e,0x79,0x3b,0xd7,0x6e,0x10,0x39,0x50,0xe1,0xb1,0xe6,0x89,0xdb,0x38,0x32,0xe5,0x2b,0x86,0x26,0x52,0xb1,0x66,0xd1,0x0b,0x45,0x0c,0xd9,0x9e,0x4e,0xd1,0xb3,0x92,0xee,0x11,0xb6,0x68,0x65,0x2b,0x87,0x08,0x9b,0x2a,0x6a,0xd9,0x13,0x85,0x4e,0x5c,0x20,0x66,0x81,0xa2,0x06,0xc8,0x1a,0x34,0x66,0xd1,0xa2,0x86,0x6d,0x9b,0x34,0x66,0xc5,0x3b,0x36,0x8d,0x19,0xb6,0x66,0xa9,0x8b,0x67,0x0e,0x5d,0xb4,0x68,0xcd,0xa3,0x45,0x0c,0xdb,0x36,0x68,0xcd,0xa2,0x86,0xce,0x1c,0xb8,0x6c,0xd1,0x43,0x67,0x08,0x1c,0x20,0x74,0x81,0xe2,0x06,0x28,0x1a,0x20,0x6c,0x79,0xa2,0x56,0xcd,0x9b,0x3b,0x72,0xe1,0xb2,0x37,0x0b,0x11,0xb8,0x40,0xed,0x03,0xd3,0xcd,0x92,0xb4,0x66,0xcd,0x8b,0x36,0xcd,0x11,0xb4,0x58,0x8d,0x8a,0x06,0x88,0x1b,0x1e,0x68,0x9d,0xb3,0x66,0xce,0xdc,0xb8,0x6c,0x8d,0xc2,0xc4,0x6e,0x10,0x3b,0x40,0xf4,0xf3,0x64,0xad,0x1d,0xbb,0x70,0xed,0xda,0x07,0xaa,0x10,0x31,0x40,0xd1,0x03,0x63,0xcd,0x13,0xb6,0x6c,0xd9,0xdb,0x97,0x0d,0x91,0xb8,0x58,0x8d,0xc2,0x07,0x68,0x1e,0x9e,0x6c,0x95,0xa3,0xb7,0x6e,0x1d,0xbb,0x3d
};

// DX Layer
const uint8_t hexMap_DX[] = {
0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0xff,0x88,0x82,0xaa,0x98,0x88,0x8a,0xaa,0x90,0x0a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x9a,0x8a,0x8a,0x8a,0x8a,0x88,0x8a,0x88,0x0a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x9a,0x8a,0x8a,0x8a,0x8a,0x8a,0x88,0x88,0x90,0x08,0x90,0x08,0x90,0x08,0x88,0x88,0x90,0x08,0x90,0x08,0x90,0x88,0x88,0x88,0x88,0x9a,0xaa,0x88,0x88,0x8a,0xaa,0x88,0x88,0x9a,0xaa,0x88,0x88,0x8a,0xaa,0x98,0x88,0x9a,0xaa,0x88,0x88,0x8a,0xaa,0x09
};

const uint8_t PROGMEM hexNotes_DX[] = {
0x50,0x95,0x3a,0x85,0x09,0x53,0xa5,0x4a,0x8d,0x01,0xe4,0x07,0x8e,0x17,0x50,0xb1,0x69,0xe6,0x6c,0xd1,0x9e,0x20,0xbd,0x43,0x17,0x0e,0x50,0x9e,0x5e,0xbd,0x62,0xf5,0xec,0x56,0x23,0x50,0xa1,0x1a,0xf4,0x67,0x93,0xa3,0x3c,0xd1,0x2a,0x06,0x68,0xcf,0x31,0x42,0x65,0x2a,0x13,0x2c,0x58,0xa5,0x42,0x5d,0x19,0xe6,0x88,0x0b,0x8d,0x40,0x65,0x9a,0x74,0x4a,0x95,0x2c,0x48,0xc1,0x82,0x45,0x88,0xd4,0x28,0x46,0xbd,0x19,0xe4,0xe8,0xcf,0x34,0x4a,0x81,0x9a,0x33,0xcc,0x50,0x99,0x4a,0x84,0xcb,0x16,0x29,0x50,0x97,0x46,0x79,0xa2,0x02,0xe3,0x50,0x19,0x66,0x9d,0x13,0x34,0xe8,0x99,0xb0,0x62,0xcd,0x8b,0x14,0xa9,0xd3,0xa3,0x50,0xa1,0x3b,0x26,0x8d,0x9c,0x31,0x62,0x95,0x3a,0x74,0xac,0xd4,0x33,0x4a,0x51,0x83,0x16,0x6a,0x16,0x2d,0x58,0x85,0x6b,0x36,0x69,0xcf,0x10,0x50,0xc5,0xc3,0x94,0x27,0x85,0x9e,0x4e,0x78,0x82,0x85,0x0b,0x16,0xac,0x46,0xb5,0x9b,0x34,0xe7,0x88,0x28,0x62,0xe1,0xca,0x13,0xcb,0xd7,0xac,0x5e,0xbd,0x8a,0x55,0x0b,0x16,0xac,0x46,0xb5,0x9b,0x34,0xe7,0x88,0x28,0x62,0xe1,0xca,0x13,0xcb,0xd7,0xac,0x5e,0xbd,0x11
};
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

const int songSize = (sizeof(hexMap_SX) / sizeof(hexMap_SX[0])) * 8; // 1 bit => 1 note
const byte noteDuration = 70;

// AUDIO DEVICES SETUP
Tone AUDIO_SX;
Tone AUDIO_DX;

// Run once
void setup() {
  AUDIO_SX.begin(3);
  AUDIO_DX.begin(2);
  playMelody();
}

// Run repeateadly
void loop() {} // Put there playMelody()??

// PLAY SONG FUNCTION
void playMelody() {

  // SX variables init
  int hexNotesIndex_SX = -1;
  byte mask_SX_1 = 0xff;
  byte mask_SX_2 = 0xff;
  byte shift_SX = 7;

  int hexNotesIndex_DX = -1;
  byte mask_DX_1 = 0xff;
  byte mask_DX_2 = 0xff;
  byte shift_DX = 7;

  int i = 0;
  while (i < songSize) {

    if(AUDIO_SX.isPlaying()) continue;
    // AUDIO_SX.stop();
    // AUDIO_DX.stop();

    // Common
    const byte haxMapIndex = i / 8;
    const byte haxMapBitIndex = 7 - (i % 8);
    const byte isNote_SX = bitRead(hexMap_SX[haxMapIndex], haxMapBitIndex); // Example: i = 5, number 0, 6th bit.
    const byte isNote_DX = bitRead(hexMap_DX[haxMapIndex], haxMapBitIndex); // Example: i = 5, number 0, 6th bit.
    i++;  // Increment only if a note or pause will play (passed AUDIO.isPlaying())


    // Check if there is something to play - if there's not, pause note
    if (!isNote_SX && !isNote_DX)
      delay(noteDuration);    // pause note
    else {

      // Play SX note, setup masks, corrections, get notes data from PROGMEM, parse it, get note index, play note
      if (isNote_SX) {

        if (mask_SX_2 == 0x00) {  // Reset variables every 8 cycles and apply correction
          mask_SX_2 = ~mask_SX_2;       // Indirectly set mask_1 to 0b00000000, mask_2 to 0b11111110
          hexNotesIndex_SX--;             // This and delete completely indexCorrection
          shift_SX = 7;
        }

        mask_SX_1 = ~mask_SX_2;         // No need to save mask_1 externally (or internally, use it direcly since it doesn't need to be stored)
        mask_SX_2 = mask_SX_2 << 1;     // Only save mask_2, used to generate the next values

        byte buffer[2];     // Save necessary values from PROGMEM into buffer
        buffer[0] = pgm_read_byte(&hexNotes_SX[hexNotesIndex_SX]);      // note chunk #1
        buffer[1] = pgm_read_byte(&hexNotes_SX[hexNotesIndex_SX + 1]);  // note chunk #

        // Use bit masks and shifts to get the 7-bits number from the PROGMEM notes layer
        const byte note_index_SX = ((buffer[0] & mask_SX_1) << shift_SX ) | ((buffer[1] & mask_SX_2) >> (8 - shift_SX));
        shift_SX--;   // Decrement shift correction (will reset to 7 when 0 aka when mask_2 == 0b00000000)
        hexNotesIndex_SX++;   // Next index MAYBE DECREMENT THIS INSTEAD OF INDEXCORRECTION

        // Actual note play :D
        AUDIO_SX.play(notes[note_index_SX], noteDuration);
      }

      if (isNote_DX) {

        if (mask_DX_2 == 0x00) {  // Reset variables every 8 cycles and apply correction
          mask_DX_2 = ~mask_DX_2;       // Indirectly set mask_1 to 0b00000000, mask_2 to 0b11111110
          hexNotesIndex_DX--;             // This and delete completely indexCorrection
          shift_DX = 7;
        }

        mask_DX_1 = ~mask_DX_2;         // No need to save mask_1 externally (or internally, use it direcly since it doesn't need to be stored)
        mask_DX_2 = mask_DX_2 << 1;     // Only save mask_2, used to generate the next values

        byte buffer[2];     // Save necessary values from PROGMEM into buffer
        buffer[0] = pgm_read_byte(&hexNotes_DX[hexNotesIndex_DX]);      // note chunk #1
        buffer[1] = pgm_read_byte(&hexNotes_DX[hexNotesIndex_DX + 1]);  // note chunk #

        // Use bit masks and shifts to get the 7-bits number from the PROGMEM notes layer
        const byte note_index_DX = ((buffer[0] & mask_DX_1) << shift_DX ) | ((buffer[1] & mask_DX_2) >> (8 - shift_DX));
        shift_DX--;   // Decrement shift correction (will reset to 7 when 0 aka when mask_2 == 0b00000000)
        hexNotesIndex_DX++;   // Next index MAYBE DECREMENT THIS INSTEAD OF INDEXCORRECTION

        // Actual note play :D
        AUDIO_DX.play(notes[note_index_DX], noteDuration);
      }
    }
  }

  delay(500);
  playMelody();
}
